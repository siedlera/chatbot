// RiveScript.js
// https://www.rivescript.com/

// This code is released under the MIT License.
// See the "LICENSE" file for more information.

// Brain logic for RiveScript

"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var utils = require("./utils");
var inherit_utils = require("./inheritance");

/**
Brain (RiveScript master)

Create a Brain object which handles the actual process of fetching a reply.
*/

var Brain = function () {
	function Brain(master) {
		_classCallCheck(this, Brain);

		var self = this;

		self.master = master;
		self.strict = master._strict;
		self.utf8 = master._utf8;

		// Private variables only relevant to the reply-answering part of RiveScript.
		self._currentUser = null; // The current user asking for a message
	}

	// Proxy functions


	_createClass(Brain, [{
		key: "say",
		value: function say(message) {
			return this.master.say(message);
		}
	}, {
		key: "warn",
		value: function warn(message, filename, lineno) {
			return this.master.warn(message, filename, lineno);
		}

		/**
  Promise reply (string user, string msg[, scope])
  	Fetch a reply for the user. This returns a Promise that may be awaited on.
  */

	}, {
		key: "reply",
		value: function () {
			var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(user, msg, scope) {
				var self, reply, begin;
				return regeneratorRuntime.wrap(function _callee$(_context) {
					while (1) {
						switch (_context.prev = _context.next) {
							case 0:
								self = this;


								self.say("Asked to reply to [" + user + "] " + msg);

								// Store the current user's ID.
								self._currentUser = user;

								// Format their message.
								msg = self.formatMessage(msg);
								reply = "";

								// Set initial match to be undefined

								if (self.master.getUservars(user)) {
									self.master._users[user].__initialmatch__ = null;
								}

								// If the BEGIN block exists, consult it first.

								if (!self.master._topics.__begin__) {
									_context.next = 20;
									break;
								}

								_context.next = 9;
								return self._getReply(user, "request", "begin", 0, scope);

							case 9:
								begin = _context.sent;

								if (!(begin.indexOf("{ok}") > -1)) {
									_context.next = 15;
									break;
								}

								_context.next = 13;
								return self._getReply(user, msg, "normal", 0, scope);

							case 13:
								reply = _context.sent;

								begin = begin.replace(/\{ok\}/g, reply);

							case 15:
								_context.next = 17;
								return self.processTags(user, msg, begin, [], [], 0, scope);

							case 17:
								reply = _context.sent;
								_context.next = 23;
								break;

							case 20:
								_context.next = 22;
								return self._getReply(user, msg, "normal", 0, scope);

							case 22:
								reply = _context.sent;

							case 23:

								// Save their reply history
								self.master._users[user].__history__.input.pop();
								self.master._users[user].__history__.input.unshift(msg);
								self.master._users[user].__history__.reply.pop();
								self.master._users[user].__history__.reply.unshift(reply);

								// Unset the current user ID.
								self._currentUser = null;

								return _context.abrupt("return", reply);

							case 29:
							case "end":
								return _context.stop();
						}
					}
				}, _callee, this);
			}));

			function reply(_x, _x2, _x3) {
				return _ref.apply(this, arguments);
			}

			return reply;
		}()

		/**
  Promise _getReply (string user, string msg, string context, int step, scope)
  	The internal reply method. DO NOT CALL THIS DIRECTLY.
  	* user, msg and scope are the same as reply()
  * context = "normal" or "begin"
  * step = the recursion depth
  * scope = the call scope for object macros
  */

	}, {
		key: "_getReply",
		value: function () {
			var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(user, msg, context, step, scope) {
				var self, topic, stars, thatstars, reply, matched, matchedTrigger, foundMatch, allTopics, j, len, top, lastReply, k, len1, trig, pattern, botside, match, _thatstars, userSide, regexp, isAtomic, isMatch, _match, l, _len, _trig, _pattern, _regexp, _isAtomic, _isMatch, _match2, i, _len2, n, redirect, o, len4, row, halves, condition, left, eq, right, potreply, passed, bucket, q, len5, rep, weight, _match3, _i, choice, _match4, giveup, name, _name, value;

				return regeneratorRuntime.wrap(function _callee2$(_context2) {
					while (1) {
						switch (_context2.prev = _context2.next) {
							case 0:
								self = this;

								// Needed to sort replies?

								if (self.master._sorted.topics) {
									_context2.next = 4;
									break;
								}

								self.warn("You forgot to call sortReplies()!");
								return _context2.abrupt("return", "ERR: Replies Not Sorted");

							case 4:

								// Initialize the user's profile?
								if (!self.master.getUservars(user)) {
									self.master.setUservar(user, "topic", "random");
								}

								// Collect data on this user.
								topic = self.master.getUservar(user, "topic");
								stars = [];
								thatstars = []; // For %Previous

								reply = "";

								// Avoid letting them fall into a missing topic.

								if (!self.master._topics[topic]) {
									self.warn("User " + user + " was in an empty topic named '" + topic + "'");
									topic = "random";
									self.master.setUservar(user, "topic", topic);
								}

								// Avoid deep recursion.

								if (!(step > self.master._depth)) {
									_context2.next = 12;
									break;
								}

								return _context2.abrupt("return", self.master.errors.deepRecursion);

							case 12:

								// Are we in the BEGIN block?
								if (context === "begin") {
									topic = "__begin__";
								}

								// Initialize this user's history.
								if (!self.master._users[user].__history__) {
									self.master._users[user].__history__ = {};
								}

								// Update input &/or reply if given array is missing or empty
								if (!self.master._users[user].__history__.input || self.master._users[user].__history__.input.length === 0) {
									self.master._users[user].__history__.input = ["undefined", "undefined", "undefined", "undefined", "undefined", "undefined", "undefined", "undefined", "undefined", "undefined"];
								}
								if (!self.master._users[user].__history__.reply || self.master._users[user].__history__.reply.length === 0) {
									self.master._users[user].__history__.reply = ["undefined", "undefined", "undefined", "undefined", "undefined", "undefined", "undefined", "undefined", "undefined", "undefined"];
								}

								// More topic sanity checking.

								if (self.master._topics[topic]) {
									_context2.next = 18;
									break;
								}

								return _context2.abrupt("return", "ERR: No default topic 'random' was found!");

							case 18:

								// Create a pointer for the matched data when we find it.
								matched = null;
								matchedTrigger = null;
								foundMatch = false;

								// See if there were any %Previous's in this topic, or any topic related
								// to it. This should only be done the first time -- not during a recursive
								// redirection. This is because in a redirection, "lastreply" is still gonna
								// be the same as it was the first time, resulting in an infinite loop!

								if (!(step === 0)) {
									_context2.next = 64;
									break;
								}

								allTopics = [topic];

								if (self.master._topics[topic].includes || self.master._topics[topic].inherits) {
									// Get ALL the topics!
									allTopics = inherit_utils.getTopicTree(self.master, topic);
								}

								// Scan them all.
								j = 0, len = allTopics.length;

							case 25:
								if (!(j < len)) {
									_context2.next = 64;
									break;
								}

								top = allTopics[j];

								self.say("Checking topic " + top + " for any %Previous's");

								if (!self.master._sorted.thats[top].length) {
									_context2.next = 60;
									break;
								}

								// There's one here!
								self.say("There's a %Previous in this topic!");

								// Do we have history yet?
								lastReply = self.master._users[user].__history__.reply[0] || "undefined";

								// Format the bot's last reply the same way as the human's.

								lastReply = self.formatMessage(lastReply, true);
								self.say("Last reply: " + lastReply);

								// See if it's a match
								k = 0, len1 = self.master._sorted.thats[top].length;

							case 34:
								if (!(k < len1)) {
									_context2.next = 58;
									break;
								}

								trig = self.master._sorted.thats[top][k];
								pattern = trig[1].previous;
								botside = self.triggerRegexp(user, pattern);


								self.say("Try to match lastReply (" + lastReply + ") to " + botside);

								// Match?
								match = lastReply.match(new RegExp("^" + botside + "$"));

								if (!match) {
									_context2.next = 55;
									break;
								}

								// Huzzah! See if OUR message is right too.
								self.say("Bot side matched!");

								_thatstars = match; // Collect the bot stars in case we need them

								_thatstars.shift();

								// Compare the triggers to the user's message.
								userSide = trig[1];
								regexp = self.triggerRegexp(user, userSide.trigger);

								self.say("Try to match \"" + msg + "\" against " + userSide.trigger + " (" + regexp + ")");

								// If the trigger is atomic, we don't need to bother with the regexp engine.
								isAtomic = utils.isAtomic(userSide.trigger);
								isMatch = false;

								if (isAtomic) {
									if (msg === regexp) {
										isMatch = true;
									}
								} else {
									_match = msg.match(new RegExp("^" + regexp + "$"));

									if (_match) {
										isMatch = true;
										// Get the stars
										stars = _match;
										if (stars.length >= 1) {
											stars.shift();
										}
									}
								}

								// Was it a match?

								if (!isMatch) {
									_context2.next = 55;
									break;
								}

								// Keep the trigger pointer.
								matched = userSide;
								foundMatch = true;
								matchedTrigger = userSide.trigger;
								return _context2.abrupt("break", 58);

							case 55:
								k++;
								_context2.next = 34;
								break;

							case 58:
								_context2.next = 61;
								break;

							case 60:
								self.say("No %Previous in this topic!");

							case 61:
								j++;
								_context2.next = 25;
								break;

							case 64:
								if (foundMatch) {
									_context2.next = 84;
									break;
								}

								self.say("Searching their topic for a match...");
								l = 0, _len = self.master._sorted.topics[topic].length;

							case 67:
								if (!(l < _len)) {
									_context2.next = 84;
									break;
								}

								_trig = self.master._sorted.topics[topic][l];
								_pattern = _trig[0];
								_regexp = self.triggerRegexp(user, _pattern);


								self.say("Try to match \"" + msg + "\" against " + _pattern + " (" + _regexp + ")");

								// If the trigger is atomic, we don't need to bother with the regexp engine.
								_isAtomic = utils.isAtomic(_pattern);
								_isMatch = false;

								if (_isAtomic) {
									if (msg === _regexp) {
										_isMatch = true;
									}
								} else {
									// Non-atomic triggers always need the regexp.
									_match2 = msg.match(new RegExp("^" + _regexp + "$"));

									if (_match2) {
										// The regexp matched!
										_isMatch = true;

										// Collect the stars
										stars = [];
										if (_match2.length > 1) {
											for (i = 1, _len2 = _match2.length; i < _len2; i++) {
												stars.push(_match2[i]);
											}
										}
									}
								}

								// A match somehow?

								if (!_isMatch) {
									_context2.next = 81;
									break;
								}

								self.say("Found a match!");

								// Keep the pointer to this trigger's data.
								matched = _trig[1];
								foundMatch = true;
								matchedTrigger = _pattern;
								return _context2.abrupt("break", 84);

							case 81:
								l++;
								_context2.next = 67;
								break;

							case 84:

								// Store what trigger they matched on. If their matched trigger is undefined,
								// this will be too, which is great.
								self.master._users[user].__lastmatch__ = matchedTrigger;
								if (step === 0) {
									// Store initial matched trigger. Like __lastmatch__, this can be undefined.
									self.master._users[user].__initialmatch__ = matchedTrigger;
									// Also initialize __last_triggers__ which will keep all matched triggers
									self.master._users[user].__last_triggers__ = [];
								}

								// Did we match?

								if (!matched) {
									_context2.next = 138;
									break;
								}

								// Keep the current match
								self.master._users[user].__last_triggers__.push(matched);

								// A single loop so we can break out early
								n = 0;

							case 89:
								if (!(n < 1)) {
									_context2.next = 138;
									break;
								}

								if (!(matched.redirect != null)) {
									_context2.next = 100;
									break;
								}

								self.say("Redirecting us to " + matched.redirect);
								_context2.next = 94;
								return self.processTags(user, msg, matched.redirect, stars, thatstars, step, scope);

							case 94:
								redirect = _context2.sent;


								self.say("Pretend user said: " + redirect);
								_context2.next = 98;
								return self._getReply(user, redirect, context, step + 1, scope);

							case 98:
								reply = _context2.sent;
								return _context2.abrupt("break", 138);

							case 100:
								o = 0, len4 = matched.condition.length;

							case 101:
								if (!(o < len4)) {
									_context2.next = 128;
									break;
								}

								row = matched.condition[o];
								halves = row.split(/\s*=>\s*/);

								if (!(halves && halves.length === 2)) {
									_context2.next = 125;
									break;
								}

								condition = halves[0].match(/^(.+?)\s+(==|eq|!=|ne|<>|<|<=|>|>=)\s+(.*?)$/);

								if (!condition) {
									_context2.next = 125;
									break;
								}

								left = utils.strip(condition[1]);
								eq = condition[2];
								right = utils.strip(condition[3]);
								potreply = halves[1].trim();

								// Process tags all around

								_context2.next = 113;
								return self.processTags(user, msg, left, stars, thatstars, step, scope);

							case 113:
								left = _context2.sent;
								_context2.next = 116;
								return self.processTags(user, msg, right, stars, thatstars, step, scope);

							case 116:
								right = _context2.sent;


								// Defaults?
								if (left.length === 0) {
									left = "undefined";
								}
								if (right.length === 0) {
									right = "undefined";
								}

								self.say("Check if " + left + " " + eq + " " + right);

								// Validate it
								passed = false;

								if (eq === "eq" || eq === "==") {
									if (left === right) {
										passed = true;
									}
								} else if (eq === "ne" || eq === "!=" || eq === "<>") {
									if (left !== right) {
										passed = true;
									}
								} else {
									try {
										// Dealing with numbers here
										left = parseInt(left);
										right = parseInt(right);
										if (eq === "<" && left < right) {
											passed = true;
										} else if (eq === "<=" && left <= right) {
											passed = true;
										} else if (eq === ">" && left > right) {
											passed = true;
										} else if (eq === ">=" && left >= right) {
											passed = true;
										}
									} catch (error) {
										e = error;
										self.warn("Failed to evaluate numeric condition!");
									}
								}

								// OK?

								if (!passed) {
									_context2.next = 125;
									break;
								}

								reply = potreply;
								return _context2.abrupt("break", 128);

							case 125:
								o++;
								_context2.next = 101;
								break;

							case 128:
								if (!(reply !== null && reply.length > 0)) {
									_context2.next = 130;
									break;
								}

								return _context2.abrupt("break", 138);

							case 130:

								// Process weights in the replies.
								bucket = [];

								for (q = 0, len5 = matched.reply.length; q < len5; q++) {
									rep = matched.reply[q];
									weight = 1;
									_match3 = rep.match(/\{weight=(\d+?)\}/i);

									if (_match3) {
										weight = _match3[1];
										if (weight <= 0) {
											self.warn("Can't have a weight <= 0!");
											weight = 1;
										}
									}

									for (_i = 0; _i < weight; _i++) {
										bucket.push(rep);
									}
								}

								// Get a random reply.
								choice = parseInt(Math.random() * bucket.length);

								reply = bucket[choice];
								return _context2.abrupt("break", 138);

							case 135:
								n++;
								_context2.next = 89;
								break;

							case 138:

								// Still no reply?
								if (!foundMatch) {
									reply = self.master.errors.replyNotMatched;
								} else if (reply === void 0 || reply.length === 0) {
									reply = self.master.errors.replyNotFound;
								}

								self.say("Reply: " + reply);

								// Process tags for the BEGIN block.

								if (!(context === "begin")) {
									_context2.next = 170;
									break;
								}

								// The BEGIN block can set {topic} and user vars.

								// Topic setter
								_match4 = reply.match(/\{topic=(.+?)\}/i);
								giveup = 0;

							case 143:
								if (!_match4) {
									_context2.next = 154;
									break;
								}

								giveup++;

								if (!(giveup >= 50)) {
									_context2.next = 148;
									break;
								}

								self.warn("Infinite loop looking for topic tag!");
								return _context2.abrupt("break", 154);

							case 148:
								name = _match4[1];

								self.master.setUservar(user, "topic", name);
								reply = reply.replace(new RegExp("{topic=" + utils.quotemeta(name) + "}", "ig"), "");
								_match4 = reply.match(/\{topic=(.+?)\}/i);
								_context2.next = 143;
								break;

							case 154:

								// Set user vars
								_match4 = reply.match(/<set (.+?)=(.+?)>/i);
								giveup = 0;

							case 156:
								if (!_match4) {
									_context2.next = 168;
									break;
								}

								giveup++;

								if (!(giveup >= 50)) {
									_context2.next = 161;
									break;
								}

								self.warn("Infinite loop looking for set tag!");
								return _context2.abrupt("break", 168);

							case 161:
								_name = _match4[1];
								value = _match4[2];


								self.master.setUservar(user, _name, value);
								reply = reply.replace(new RegExp("<set " + utils.quotemeta(_name) + "=" + utils.quotemeta(value) + ">", "ig"), "");
								_match4 = reply.match(/<set (.+?)=(.+?)>/i);
								_context2.next = 156;
								break;

							case 168:
								_context2.next = 171;
								break;

							case 170:
								// Process all the tags.
								reply = self.processTags(user, msg, reply, stars, thatstars, step, scope);

							case 171:
								return _context2.abrupt("return", reply);

							case 172:
							case "end":
								return _context2.stop();
						}
					}
				}, _callee2, this);
			}));

			function _getReply(_x4, _x5, _x6, _x7, _x8) {
				return _ref2.apply(this, arguments);
			}

			return _getReply;
		}()

		/**
  string formatMessage (string msg)
  	Format a user's message for safe processing.
  */

	}, {
		key: "formatMessage",
		value: function formatMessage(msg, botreply) {
			var self = this;

			// Lowercase it.
			msg = "" + msg;
			msg = msg.toLowerCase();

			// Run substitutions and sanitize what's left.
			msg = self.substitute(msg, "sub");

			// In UTF-8 mode, only strip metacharcters and HTML brackets (to protect
			// against obvious XSS attacks).
			if (self.utf8) {
				msg = msg.replace(/[\\<>]+/, "");

				if (self.master.unicodePunctuation != null) {
					msg = msg.replace(self.master.unicodePunctuation, "");
				}

				// For the bot's reply, also strip common punctuation.
				if (botreply != null) {
					msg = msg.replace(/[.?,!;:@#$%^&*()]/, "");
				}
			} else {
				// For everything else, strip all non-alphanumerics
				msg = utils.stripNasties(msg, self.utf8);
			}

			// cut leading and trailing blanks once punctuation dropped office
			msg = msg.trim();
			msg = msg.replace(/\s+/g, " ");
			return msg;
		}

		/**
  string triggerRegexp (string user, string trigger)
  	Prepares a trigger for the regular expression engine.
  */

	}, {
		key: "triggerRegexp",
		value: function triggerRegexp(user, regexp) {
			var self = this;

			// If the trigger is simply '*' then the * needs to become (.*?)
			// to match the blank string too.
			regexp = regexp.replace(/^\*$/, "<zerowidthstar>");

			// Simple replacements.
			regexp = regexp.replace(/\*/g, "(.+?)"); // Convert * into (.+?)
			regexp = regexp.replace(/#/g, "(\\d+?)"); // Convert # into (\d+?)
			regexp = regexp.replace(/_/g, "(\\w+?)"); // Convert _ into (\w+?)
			regexp = regexp.replace(/\s*\{weight=\d+\}\s*/g, ""); // Remove {weight} tags
			regexp = regexp.replace(/<zerowidthstar>/g, "(.*?)");
			regexp = regexp.replace(/\|{2,}/, '|'); // Remove empty entities
			regexp = regexp.replace(/(\(|\[)\|/g, '$1'); // Remove empty entities from start of alt/opts
			regexp = regexp.replace(/\|(\)|\])/g, '$1'); // Remove empty entities from end of alt/opts

			// UTF-8 mode special characters.
			if (self.utf8) {
				regexp = regexp.replace(/\\@/, "\\u0040"); // @ symbols conflict w/ arrays
			}

			// Optionals.
			var match = regexp.match(/\[(.+?)\]/);
			var giveup = 0;
			while (match) {
				if (giveup++ > 50) {
					self.warn("Infinite loop when trying to process optionals in a trigger!");
					return "";
				}

				// The resulting regexp needs to work in two scenarios:
				// 1) The user included the optional word(s) in which case they must be
				//    in the message surrounded by a space or a word boundary (e.g. the
				//    end or beginning of their message)
				// 2) The user did not include the word, meaning the whole entire set of
				//    words should be "OR'd" with a word boundary or one or more spaces.
				//
				// The resulting regexp ends up looking like this, for a given input
				// trigger of: what is your [home|office] number
				// what is your(?:(?:\s|\b)+home(?:\s|\b)+|(?:\s|\b)+office(?:\s|\b)+|(?:\b|\s)+)number
				//
				// See https://github.com/aichaos/rivescript-js/issues/48

				var parts = match[1].split("|");
				var opts = [];
				for (var j = 0, len = parts.length; j < len; j++) {
					var p = parts[j];
					opts.push("(?:\\s|\\b)+" + p + "(?:\\s|\\b)+");
				}

				// If this optional had a star or anything in it, make it non-matching.
				var pipes = opts.join("|");
				pipes = pipes.replace(new RegExp(utils.quotemeta("(.+?)"), "g"), "(?:.+?)");
				pipes = pipes.replace(new RegExp(utils.quotemeta("(\\d+?)"), "g"), "(?:\\d+?)");
				pipes = pipes.replace(new RegExp(utils.quotemeta("(\\w+?)"), "g"), "(?:\\w+?)");

				// Temporarily dummy out the literal square brackets so we don't loop forever
				// thinking that the [\s\b] part is another optional.
				pipes = pipes.replace(/\[/g, "__lb__").replace(/\]/g, "__rb__");
				regexp = regexp.replace(new RegExp("\\s*\\[" + utils.quotemeta(match[1]) + "\\]\\s*"), "(?:" + pipes + "|(?:\\b|\\s)+)");
				match = regexp.match(/\[(.+?)\]/);
			}

			// Restore the literal square brackets.
			regexp = regexp.replace(/__lb__/g, "[").replace(/__rb__/g, "]");

			// _ wildcards can't match numbers! Quick note on why I did it this way:
			// the initial replacement above (_ => (\w+?)) needs to be \w because the
			// square brackets in [\s\d] will confuse the optionals logic just above.
			// So then we switch it back down here. Also, we don't just use \w+ because
			// that matches digits, and similarly [A-Za-z] doesn't work with Unicode,
			// so this regexp excludes spaces and digits instead of including letters.
			regexp = regexp.replace(/\\w/, "[^\\s\\d]");

			// Filter in arrays.
			giveup = 0;
			while (regexp.indexOf("@") > -1) {
				if (giveup++ > 50) {
					break;
				}
				var _match5 = regexp.match(/\@(.+?)\b/);
				if (_match5) {
					var name = _match5[1];
					var rep = "";
					if (self.master._array[name]) {
						rep = "(?:" + self.master._array[name].join("|") + ")";
					}
					regexp = regexp.replace(new RegExp("@" + utils.quotemeta(name) + "\\b"), rep);
				}
			}

			// Filter in bot variables.
			giveup = 0;
			while (regexp.indexOf("<bot") > -1) {
				if (giveup++ > 50) {
					break;
				}
				var _match6 = regexp.match(/<bot (.+?)>/i);
				if (_match6) {
					var _name2 = _match6[1];
					var _rep = '';
					if (self.master._var[_name2]) {
						_rep = utils.stripNasties(self.master._var[_name2]);
					}
					regexp = regexp.replace(new RegExp("<bot " + utils.quotemeta(_name2) + ">"), _rep.toLowerCase());
				}
			}
			// Filter in user variables.
			giveup = 0;
			while (regexp.indexOf("<get") > -1) {
				if (giveup++ > 50) {
					break;
				}

				var _match7 = regexp.match(/<get (.+?)>/i);
				if (_match7) {
					var _name3 = _match7[1];
					var _rep2 = self.master.getUservar(user, _name3);
					regexp = regexp.replace(new RegExp("<get " + utils.quotemeta(_name3) + ">", "ig"), _rep2.toLowerCase());
				}
			}
			// Filter in input/reply tags.
			giveup = 0;
			regexp = regexp.replace(/<input>/i, "<input1>");
			regexp = regexp.replace(/<reply>/i, "<reply1>");
			while (regexp.indexOf("<input") > -1 || regexp.indexOf("<reply") > -1) {
				if (giveup++ > 50) {
					break;
				}
				var ref = ["input", "reply"];
				for (var k = 0, len1 = ref.length; k < len1; k++) {
					var type = ref[k];
					for (var i = 1; i <= 9; i++) {
						if (regexp.indexOf("<" + type + i + ">") > -1) {
							regexp = regexp.replace(new RegExp("<" + type + i + ">", "g"), self.master._users[user].__history__[type][i - 1]);
						}
					}
				}
			}

			// Recover escaped Unicode symbols.
			if (self.utf8 && regexp.indexOf("\\u") > -1) {
				regexp = regexp.replace(/\\u([A-Fa-f0-9]{4})/, function (match, grp) {
					return String.fromCharCode(parseInt(grp, 16));
				});
			}

			// Prevent accidental wildcard match due to double-pipe (e.g. /hi||hello/)
			regexp = regexp.replace(/\|{2,}/mg, '|');
			return regexp;
		}

		/**
  string processTags (string user, string msg, string reply, string[] stars,
                      string[] botstars, int step, scope)
  	Process tags in a reply element.
  */

	}, {
		key: "processTags",
		value: function () {
			var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(user, msg, reply, st, bst, step, scope) {
				var self, stars, botstars, match, giveup, name, result, i, len, _i2, _len3, _i3, random, text, output, formats, m, _len4, type, content, replace, parts, tag, data, insert, target, _name4, value, _result, _name5, _target, subreply, _parts, _output, obj, args, lang;

				return regeneratorRuntime.wrap(function _callee3$(_context3) {
					while (1) {
						switch (_context3.prev = _context3.next) {
							case 0:
								self = this;

								// Prepare the stars and botstars.

								stars = [""];

								stars.push.apply(stars, st);
								botstars = [""];

								botstars.push.apply(botstars, bst);
								if (stars.length === 1) {
									stars.push("undefined");
								}
								if (botstars.length === 1) {
									botstars.push("undefined");
								}

								// Turn arrays into randomized sets.
								match = reply.match(/\(@([A-Za-z0-9_]+)\)/i);
								giveup = 0;

							case 9:
								if (!match) {
									_context3.next = 20;
									break;
								}

								if (!(giveup++ > self.master._depth)) {
									_context3.next = 13;
									break;
								}

								self.warn("Infinite loop looking for arrays in reply!");
								return _context3.abrupt("break", 20);

							case 13:
								name = match[1];
								result = void 0;

								if (self.master._array[name]) {
									result = "{random}" + self.master._array[name].join("|") + "{/random}";
								} else {
									// Dummy it out so we can reinsert it later.
									result = "\0@" + name + "\0";
								}

								reply = reply.replace(new RegExp("\\(@" + utils.quotemeta(name) + "\\)", "ig"), result);
								match = reply.match(/\(@([A-Za-z0-9_]+)\)/i);
								_context3.next = 9;
								break;

							case 20:

								// Restore literal arrays that didn't exist.
								reply = reply.replace(/\x00@([A-Za-z0-9_]+)\x00/g, "(@$1)");

								// Tag shortcuts.
								reply = reply.replace(/<person>/ig, "{person}<star>{/person}");
								reply = reply.replace(/<@>/ig, "{@<star>}");
								reply = reply.replace(/<formal>/ig, "{formal}<star>{/formal}");
								reply = reply.replace(/<sentence>/ig, "{sentence}<star>{/sentence}");
								reply = reply.replace(/<uppercase>/ig, "{uppercase}<star>{/uppercase}");
								reply = reply.replace(/<lowercase>/ig, "{lowercase}<star>{/lowercase}");

								// Weight and star tags.
								reply = reply.replace(/\{weight=\d+\}/ig, ""); // Remove {weight}s
								reply = reply.replace(/<star>/ig, stars[1]);
								reply = reply.replace(/<botstar>/ig, botstars[1]);
								for (i = 1, len = stars.length; i <= len; i++) {
									reply = reply.replace(new RegExp("<star" + i + ">", "ig"), stars[i]);
								}
								for (_i2 = 1, _len3 = stars.length; _i2 <= _len3; _i2++) {
									reply = reply.replace(new RegExp("<botstar" + _i2 + ">", "ig"), botstars[_i2]);
								}

								// <input> and <reply>
								reply = reply.replace(/<input>/ig, self.master._users[user].__history__.input[0] || "undefined");
								reply = reply.replace(/<reply>/ig, self.master._users[user].__history__.reply[0] || "undefined");
								for (_i3 = 1; _i3 <= 9; _i3++) {
									if (reply.indexOf("<input" + _i3 + ">") > -1) {
										reply = reply.replace(new RegExp("<input" + _i3 + ">", "ig"), self.master._users[user].__history__.input[_i3 - 1]);
									}
									if (reply.indexOf("<reply" + _i3 + ">") > -1) {
										reply = reply.replace(new RegExp("<reply" + _i3 + ">", "ig"), self.master._users[user].__history__.reply[_i3 - 1]);
									}
								}

								// <id> and escape codes
								reply = reply.replace(/<id>/ig, user);
								reply = reply.replace(/\\s/ig, " ");
								reply = reply.replace(/\\n/ig, "\n");
								reply = reply.replace(/\\#/ig, "#");

								// {random}
								match = reply.match(/\{random\}(.+?)\{\/random\}/i);
								giveup = 0;

							case 41:
								if (!match) {
									_context3.next = 53;
									break;
								}

								if (!(giveup++ > self.master._depth)) {
									_context3.next = 45;
									break;
								}

								self.warn("Infinite loop looking for random tag!");
								return _context3.abrupt("break", 53);

							case 45:
								random = [];
								text = match[1];

								if (text.indexOf("|") > -1) {
									random = text.split("|");
								} else {
									random = text.split(" ");
								}

								output = random[parseInt(Math.random() * random.length)];

								reply = reply.replace(new RegExp("\\{random\\}" + utils.quotemeta(text) + "\\{\\/random\\}", "ig"), output);
								match = reply.match(/\{random\}(.+?)\{\/random\}/i);
								_context3.next = 41;
								break;

							case 53:

								// Person substitutions & string formatting
								formats = ["person", "formal", "sentence", "uppercase", "lowercase"];
								m = 0, _len4 = formats.length;

							case 55:
								if (!(m < _len4)) {
									_context3.next = 74;
									break;
								}

								type = formats[m];

								match = reply.match(new RegExp("{" + type + "}(.+?){/" + type + "}", "i"));
								giveup = 0;

							case 59:
								if (!match) {
									_context3.next = 71;
									break;
								}

								giveup++;

								if (!(giveup >= 50)) {
									_context3.next = 64;
									break;
								}

								self.warn("Infinite loop looking for " + type + " tag!");
								return _context3.abrupt("break", 71);

							case 64:
								content = match[1];
								replace = void 0;

								if (type === "person") {
									replace = self.substitute(content, "person");
								} else {
									replace = utils.stringFormat(type, content);
								}

								reply = reply.replace(new RegExp("{" + type + "}" + utils.quotemeta(content) + ("{/" + type + "}"), "ig"), replace);
								match = reply.match(new RegExp("{" + type + "}(.+?){/" + type + "}", "i"));
								_context3.next = 59;
								break;

							case 71:
								m++;
								_context3.next = 55;
								break;

							case 74:

								// Handle all variable-related tags with an iterative regexp approach, to
								// allow for nesting of tags in arbitrary ways (think <set a=<get b>>)
								// Dummy out the <call> tags first, because we don't handle them right here.
								reply = reply.replace(/<call>/ig, "«__call__»");
								reply = reply.replace(/<\/call>/ig, "«/__call__»");

							case 76:
								if (!true) {
									_context3.next = 90;
									break;
								}

								// This regexp will match a <tag> which contains no other tag inside it,
								// i.e. in the case of <set a=<get b>> it will match <get b> but not the
								// <set> tag, on the first pass. The second pass will get the <set> tag,
								// and so on.
								match = reply.match(/<([^<]+?)>/);

								if (match) {
									_context3.next = 80;
									break;
								}

								return _context3.abrupt("break", 90);

							case 80:

								match = match[1];
								parts = match.split(" ");
								tag = parts[0].toLowerCase();
								data = "";

								if (parts.length > 1) {
									data = parts.slice(1).join(" ");
								}
								insert = "";

								// Handle the tags.

								if (tag === "bot" || tag === "env") {
									// <bot> and <env> tags are similar
									target = tag === "bot" ? self.master._var : self.master._global;

									if (data.indexOf("=") > -1) {
										// Assigning a variable
										parts = data.split("=", 2);
										self.say("Set " + tag + " variable " + parts[0] + " = " + parts[1]);
										target[parts[0]] = parts[1];
									} else {
										// Getting a bot/env variable
										insert = target[data] || "undefined";
									}
								} else if (tag === "set") {
									// <set> user vars
									parts = data.split("=", 2);
									self.say("Set uservar " + parts[0] + " = " + parts[1]);
									self.master.setUservar(user, parts[0], parts[1]);
								} else if (tag === "add" || tag === "sub" || tag === "mult" || tag === "div") {
									// Math operator tags
									parts = data.split("=");
									_name4 = parts[0];
									value = parts[1];

									// Initialize the variable?

									if (self.master.getUservar(user, _name4) === "undefined") {
										self.master.setUservar(user, _name4, 0);
									}

									// Sanity check
									value = parseInt(value);
									if (isNaN(value)) {
										insert = "[ERR: Math can't '" + tag + "' non-numeric value '" + value + "']";
									} else if (isNaN(parseInt(self.master.getUservar(user, _name4)))) {
										insert = "[ERR: Math can't '" + tag + "' non-numeric user variable '" + _name4 + "']";
									} else {
										_result = parseInt(self.master.getUservar(user, _name4));

										if (tag === "add") {
											_result += value;
										} else if (tag === "sub") {
											_result -= value;
										} else if (tag === "mult") {
											_result *= value;
										} else if (tag === "div") {
											if (value === 0) {
												insert = "[ERR: Can't Divide By Zero]";
											} else {
												_result /= value;
											}
										}

										// No errors?
										if (insert === "") {
											self.master.setUservar(user, _name4, _result);
										}
									}
								} else if (tag === "get") {
									insert = self.master.getUservar(user, data);
								} else {
									// Unrecognized tag, preserve it
									insert = "\0" + match + "\x01";
								}
								reply = reply.replace(new RegExp("<" + utils.quotemeta(match) + ">"), insert);
								_context3.next = 76;
								break;

							case 90:

								// Recover mangled HTML-like tags
								reply = reply.replace(/\x00/g, "<");
								reply = reply.replace(/\x01/g, ">");

								// Topic setter
								match = reply.match(/\{topic=(.+?)\}/i);
								giveup = 0;

							case 94:
								if (!match) {
									_context3.next = 105;
									break;
								}

								giveup++;

								if (!(giveup >= 50)) {
									_context3.next = 99;
									break;
								}

								self.warn("Infinite loop looking for topic tag!");
								return _context3.abrupt("break", 105);

							case 99:
								_name5 = match[1];

								self.master.setUservar(user, "topic", _name5);
								reply = reply.replace(new RegExp("{topic=" + utils.quotemeta(_name5) + "}", "ig"), "");
								match = reply.match(/\{topic=(.+?)\}/i); // Look for more
								_context3.next = 94;
								break;

							case 105:

								// Inline redirector
								match = reply.match(/\{@([^\}]*?)\}/);
								giveup = 0;

							case 107:
								if (!match) {
									_context3.next = 121;
									break;
								}

								giveup++;

								if (!(giveup >= 50)) {
									_context3.next = 112;
									break;
								}

								self.warn("Infinite loop looking for redirect tag!");
								return _context3.abrupt("break", 121);

							case 112:
								_target = utils.strip(match[1]);

								self.say("Inline redirection to: " + _target);

								_context3.next = 116;
								return self._getReply(user, _target, "normal", step + 1, scope);

							case 116:
								subreply = _context3.sent;

								reply = reply.replace(new RegExp("\\{@" + utils.quotemeta(match[1]) + "\\}", "i"), subreply);
								match = reply.match(/\{@([^\}]*?)\}/);
								_context3.next = 107;
								break;

							case 121:

								// Object caller
								reply = reply.replace(/«__call__»/g, "<call>");
								reply = reply.replace(/«\/__call__»/g, "</call>");
								match = reply.match(/<call>([\s\S]+?)<\/call>/);
								giveup = 0;

							case 125:
								if (!match) {
									_context3.next = 156;
									break;
								}

								giveup++;

								if (!(giveup >= 50)) {
									_context3.next = 130;
									break;
								}

								self.warn("Infinite loop looking for call tags!");
								return _context3.abrupt("break", 156);

							case 130:
								_parts = utils.trim(match[1]).split(" ");
								_output = self.master.errors.objectNotFound;
								obj = _parts[0];

								// Make the args shell-like.

								args = [];

								if (_parts.length > 1) {
									args = utils.parseCallArgs(_parts.slice(1).join(" "));
								}

								// Do we know self object?

								if (!(obj in self.master._objlangs)) {
									_context3.next = 152;
									break;
								}

								// We do, but do we have a handler for that language?
								lang = self.master._objlangs[obj];

								if (!(lang in self.master._handlers)) {
									_context3.next = 151;
									break;
								}

								_context3.prev = 138;
								_context3.next = 141;
								return self.master._handlers[lang].call(self.master, obj, args, scope);

							case 141:
								_output = _context3.sent;
								_context3.next = 149;
								break;

							case 144:
								_context3.prev = 144;
								_context3.t0 = _context3["catch"](138);

								e = _context3.t0;
								self.warn(e.message);
								_output = "[ERR: Error raised by object macro]";

							case 149:
								_context3.next = 152;
								break;

							case 151:
								_output = "[ERR: No Object Handler]";

							case 152:
								reply = reply.replace(match[0], _output);
								match = reply.match(/<call>(.+?)<\/call>/);
								_context3.next = 125;
								break;

							case 156:
								return _context3.abrupt("return", reply);

							case 157:
							case "end":
								return _context3.stop();
						}
					}
				}, _callee3, this, [[138, 144]]);
			}));

			function processTags(_x9, _x10, _x11, _x12, _x13, _x14, _x15) {
				return _ref3.apply(this, arguments);
			}

			return processTags;
		}()

		/**
  string substitute (string msg, string type)
  	Run substitutions against a message. `type` is either "sub" or "person" for
  the type of substitution to run.
  */

	}, {
		key: "substitute",
		value: function substitute(msg, type) {
			var self = this;

			// Safety checking.
			if (!self.master._sorted[type]) {
				self.master.warn("You forgot to call sortReplies()!");
				return "";
			}

			// Get the substitutions map.
			var subs = type === "sub" ? self.master._sub : self.master._person;

			// Get the max number of words in sub/person to minimize interations
			var maxwords = type === "sub" ? self.master._submax : self.master._personmax;
			var result = "";

			// Take the original message with no punctuation
			var pattern;
			if (self.master.unicodePunctuation != null) {
				pattern = msg.replace(self.master.unicodePunctuation, "");
			} else {
				pattern = msg.replace(/[.,!?;:]/g, "");
			}

			var tries = 0;
			var giveup = 0;
			var subgiveup = 0;

			// Look for words/phrases until there is no "spaces" in pattern
			while (pattern.indexOf(" ") > -1) {
				giveup++;
				// Give up if there are too many substitutions (for safety)
				if (giveup >= 1000) {
					self.warn("Too many loops when handling substitutions!");
					break;
				}

				var li = utils.nIndexOf(pattern, " ", maxwords);
				var subpattern = pattern.substring(0, li);

				// If finds the pattern in sub object replace and stop to look
				result = subs[subpattern];
				if (result !== undefined) {
					msg = msg.replace(subpattern, result);
				} else {
					// Otherwise Look for substitutions in a subpattern
					while (subpattern.indexOf(" ") > -1) {
						subgiveup++;

						// Give up if there are too many substitutions (for safety)
						if (subgiveup >= 1000) {
							self.warn("Too many loops when handling substitutions!");
							break;
						}

						li = subpattern.lastIndexOf(" ");
						subpattern = subpattern.substring(0, li);

						// If finds the subpattern in sub object replace and stop to look
						result = subs[subpattern];
						if (result !== undefined) {
							msg = msg.replace(subpattern, result);
							break;
						}

						tries++;
					}
				}

				var fi = pattern.indexOf(" ");
				pattern = pattern.substring(fi + 1);
				tries++;
			}

			// After all loops, see if just one word is in the pattern
			result = subs[pattern];
			if (result !== undefined) {
				msg = msg.replace(pattern, result);
			}

			return msg;
		}
	}]);

	return Brain;
}();

;

module.exports = Brain;